/******* Do not edit this file *******
Woody Code Snippets CSS and JS
Saved: May 10 2024 | 15:59:38 */
// Neo4j HTTP endpoint for Cypher transaction API
// https://www.515tech.com/post/visualize-neo4j-graphs-using-d3-html-canvas
// https://gitlab.com/cmg_public/blogs/visualizing-neo4j-graphs-with-d3.js-and-html5-canvas/-/blob/main/index.js?ref_type=heads
const neo4j_http_url = "http://127.0.0.1:7474/db/neo4j/tx"
const neo4jUsername = "neo4j"
const neo4jPassword = "rmc2024IAML"

// used for drawing nodes and arrows later on
const circleSize = 30
const arrowHeight = 5
const arrowWidth = 5

const submitQuery = () => {
    // Create new, empty objects to hold the nodes and relationships returned by the query results
    let nodeItemMap = {}
    let linkItemMap = {}

    // contents of the query text field
	const cypherString = document.querySelector('#queryContainer').value
		
    // make POST request with auth headers
    let response = fetch(neo4j_http_url, {
        method: 'POST',
        // authentication using the username and password of the user in Neo4j
        headers: {
            "Authorization": "Basic " + btoa(`${neo4jUsername}:${neo4jPassword}`),
            "Content-Type": "application/json",
            "Accept": "application/json;charset=UTF-8",
        },
        // Formatted request for Neo4j's Cypher Transaction API with generated query included
        // https://neo4j.com/docs/http-api/current/actions/query-format/
        // generated query is formatted to be valid JSON for insertion into request body
        body: '{"statements":[{"statement":"' + cypherString.replace(/(\r\n|\n|\r)/gm, "\\n").replace(/"/g, '\\"') + '", "resultDataContents":["graph", "row"]}]}'
    })
        .then(res => res.json())
        .then(data => { // usable data from response JSON

            // if errors present in the response from Neo4j, propagate alert() dialog box with the error
            if (data.errors != null && data.errors.length > 0) {
                alert(`Error:${data.errors[0].message}(${data.errors[0].code})`);
            }
			console.log(data);
            // if results within valid data are not null or empty, extract the returned nodes/relationships into nodeItemMap and linkItemMap respectively
            if (data.results != null && data.results.length > 0 && data.results[0].data != null && data.results[0].data.length > 0) {
                let neo4jDataItmArray = data.results[0].data;
                neo4jDataItmArray.forEach(function (dataItem) { // iterate through all items in the embedded 'results' element returned from Neo4j, https://neo4j.com/docs/http-api/current/actions/result-format/
                    //Node
                    if (dataItem.graph.nodes != null && dataItem.graph.nodes.length > 0) {
                        let neo4jNodeItmArray = dataItem.graph.nodes; // all nodes present in the results item
						/*console.log("neo4jNodeItmArray");
						console.log(neo4jNodeItmArray);*/
						
                        neo4jNodeItmArray.forEach(function (nodeItm) {
                            if (!(nodeItm.id in nodeItemMap)) // if node is not yet present, create new entry in nodeItemMap whose key is the node ID and value is the node itself
                                nodeItemMap[nodeItm.id] = nodeItm;
								//nodeItemMap[nodeItm.id]["name"]=nodeItm.properties.id;
								nodeItemMap[nodeItm.id]["properties"]["name"]=nodeItm.properties.id;
                        });
                    }
                    //Link, interchangeably called a relationship
                    if (dataItem.graph.relationships != null && dataItem.graph.relationships.length > 0) {
                        let neo4jLinkItmArray = dataItem.graph.relationships; // all relationships present in the results item
						
						/*console.log("neo4jLinkItmArray");
						console.log(neo4jLinkItmArray);*/
						
                        neo4jLinkItmArray.forEach(function (linkItm) {
                            if (!(linkItm.id in linkItemMap)) { // if link is not yet present, create new entry in linkItemMap whose key is the link ID and value is the link itself
                                // D3 force layout graph uses 'startNode' and 'endNode' to determine link start/end points, these are called 'source' and 'target' in JSON results from Neo4j
                                linkItm.source = linkItm.startNode;
                                linkItm.target = linkItm.endNode;
                                linkItemMap[linkItm.id] = linkItm;
                            }
                        });
                    }
                });
            }
			
			console.log("linkItemMap");
			console.log(linkItemMap);
			
			console.log("nodeItemMap");
			console.log(nodeItemMap);
			
            // update the D3 force layout graph with the properly formatted lists of nodes and links from Neo4j
            updateGraph(Object.values(nodeItemMap), Object.values(linkItemMap));
        });
}



//##################################################
// create a new D3 force simulation with the nodes and links returned from a query to Neo4j for display on the canvas element
function updateGraph(nodes, links) {
    const width = 800;
    const height = 500;
	
	
    // Create a map to store unique labels and assign them colors
	const labels = [...new Set(nodes.map(d => d.labels[0]))];
	
	// Specify the color scale.
	const color = d3.scaleOrdinal(d3.schemeCategory10).domain(labels);
	
	console.log(labels);
	
    // The force simulation mutates links and nodes, so create a copy
    const copiedLinks = links.map(d => ({...d}));
    const copiedNodes = nodes.map(d => ({...d}));

    // Create a simulation with several forces.
    const simulation = d3.forceSimulation(copiedNodes)
        .force("link", d3.forceLink(copiedLinks).id(d => d.id).distance(400)) 
		.force("charge", d3.forceManyBody())
	    .force("collide", d3.forceCollide().radius(25)) // Added forceCollide with a radius slightly larger than the node's radius
		.force("x", d3.forceX())
        .force("y", d3.forceY())
	 	.on("tick", ticked);

	
	/*
	
	> width and height are the dimensions for the SVG container.
	> color is a D3 scale that assigns colors to nodes based on their group.
	> copiedLinks and copiedNodes are copies of the original links and 	   > nodes arrays to avoid mutation.
	> simulation is a D3 force simulation that will handle the physics of the nodes and links.
	
	*/
	
	
	/*
	
		#d3.forceSimulation(copiedNodes)
		This initializes a new force simulation with an array of nodes (copiedNodes). A force simulation is a mathematical model that simulates how forces act on nodes in a graph to determine their positions.

		#.force("link", d3.forceLink(copiedLinks).id(d => d.id).distance(400))
		d3.forceLink(copiedLinks): This creates a new link force that establishes the relationships between the nodes based on the copiedLinks data.
		.id(d => d.id): This sets the identifier function for the links, which helps in establishing the links correctly.
		.distance(400): This sets the desired distance between linked nodes to 400 units. Increasing this value will spread the nodes farther apart, and decreasing it will bring them closer.

		#.force("charge", d3.forceManyBody())
		d3.forceManyBody(): This force applies a "charge" to each node. Nodes with a positive charge will repel each other, and nodes with a negative charge will attract each other.
		
		#.force("x", d3.forceX()) and .force("y", d3.forceY())
		d3.forceX(): This force attracts nodes to a given x position. By default, the x position is set to the center of the SVG.
		#d3.forceY(): This force attracts nodes to a given y position. By default, the y position is set to the center of the SVG.

		#.on("tick", ticked)
		.on("tick", ticked): This sets up the tick event handler, which is called for each step of the simulation. Inside this function, we update the positions of the nodes and links based on the current state of the simulation.

		---------------------------------
		function ticked() {...}
		In the ticked function:

		The link attributes (x1, y1, x2, y2) are updated based on the positions of the source and target nodes.
		The node attributes (cx, cy) are updated based on the current node positions.
		The label positions are updated to follow the nodes.
		---------------------------------
	*/
	
	
    // Create the SVG container.
    const svg = d3.select('#graphSvg')
        .attr("width", width)
        .attr("height", height)
     	.attr("viewBox", [-width / 2, -height / 2, width, height])
		.attr("style", "max-width: 100%; height: auto;")
        .style("background-color", "white");  // add white background

	/*
	
	 # attr("width", width) and attr("height", height) set the width and height of the SVG container.
	# attr("viewBox", [-width / 2, -height / 2, width, height]) centers the content of the SVG.
	# .attr("style", "max-width: 100%; height: auto;") ensures that the SVG is responsive and scales according to its container.
	# .style("background-color", "white") sets a white background color for the SVG.
	
	*/
	
		// Clear previous elements
    svg.selectAll("*").remove();
	
	
	/*
	
		> The SVG container is selected by its ID #graphSvg.
		> We set its dimensions, viewbox, and style.
		> We clear any previous elements to ensure a clean slate for the new graph.
	
	*/
	
    // Add zoom functionality
    const zoom = d3.zoom()
        .scaleExtent([0.05, 10])
        .on('zoom', zoomed);

    svg.call(zoom);
	
	/*
		> Adds zoom functionality to the SVG container with a specified scale extent.
		> Calls the zoomed function when the zoom event occurs.
	*/
    
	const container = svg.append("g");

	    // Define the arrowhead
    const arrowhead = container.append("defs").append("marker")
        .attr("id", "arrowhead")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 8)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("fill", "LightSlateGray")
        .attr("d", "M0,-5L10,0L0,5");
	
	
	// Add fixed circles based on node labels in the top left corner
	const fixedCircles = svg.append("g")
		.attr("class", "fixedCircle")
        .attr("transform", (d, i) => `translate(${-width / 2 + 20},${-height / 2 + 20 + i * 25})`);

	fixedCircles.selectAll("circle")
		.data(labels)
		.enter().append("circle")
		.attr("r", 10)
		.attr("cx", 0) // Set cx to 0 to align with the left edge
		.attr("cy", (d, i) => i * 25)
		.attr("fill", d => color(d));

	fixedCircles.selectAll("text")
		.data(labels)
		.enter().append("text")
		.attr("x", 15)
		.attr("y", (d, i) => 5 + i * 25)
		.text(d => d);
	
    // Add links
    const link = container.append("g")
        .attr("class", "links")
        .attr("stroke", "#999")
        .attr("stroke-opacity", 1)
        .selectAll("line")
        .data(copiedLinks)
        .join("line")
        .attr("stroke", d => color(d.type))
        .attr("marker-end", "url(#arrowhead)")  
        .attr("stroke-width", d => Math.sqrt(d.value));

    // Add nodes
    const node = container.append("g")
        .attr("stroke", "#fff")
        .attr("stroke-width", 1.5)
        .selectAll("circle")
        .data(copiedNodes)
        .join("circle")
        .attr("r", 20)
        .attr("fill", d => color(d.labels[0])) // Use the label to determine color
        .on("mouseover", handleMouseover) // Add mouseover event
        .on("mousemove", handleMousemove)  // Add mousemove event
        .on("mouseout", handleMouseout)
		.on("click", handleClick);  // Add mouseout event
	
	/*  .on("mouseover", function() { d3.select(this).attr("fill", "#ff5733"); })
        .on("mouseout", function(d) { d3.select(this).attr("fill", color(d.group)); })
	    .on("click", handleClick) // Add click event
        .on("mousemove", handleMousemove)  // Add mousemove event
        .on("mouseout", handleMouseout);  // Add mouseout event		*/
	
	/*
		> We create a container group within the SVG to hold the links and nodes.
		> The link group contains the line elements representing the links between nodes.
		> The node group contains the circle elements representing the nodes. 
		> This also includes a click event that triggers the handleClick function when a node is clicked.
	
	*/
	
    // Add node labels outside the node at the bottom
    const label = container.append("g")
        .selectAll()
        .data(copiedNodes)
        .join("text")
        .attr("dy", 30)  // position the text below the circle
        .attr("text-anchor", "middle")
        .text(d => d.id);

	/*
		> Labels are added to each node to display their ID below the node.	
	*/
	
    // Tooltip
	 const tooltip = d3.select("body").append("div")
        .attr("id", "tooltip")
        .style("position", "absolute")
        .style("visibility", "hidden")
        .style("background-color", "#00c2a9")
        .style("color", "#fff")
        .style("padding", "5px")
        .style("border-radius", "5px")
	    .style("font-size", "14px"); // Set font size

	// JSmol integration
    /*const jsmolApplet = Jmol.getApplet("jsmolApplet", {
        width: 350,
        height: 350,
        color: "0xCCCCCC",
        j2sPath: "http://localhost:8080/wp-content/plugins/jsmol2wp/j2s",
        serverURL: "http://localhost:8080/wp-content/plugins/jsmol2wp/php/jsmol.php",
        script: "load https://files.rcsb.org/view/6w12.pdb; background white"
    });

    function loadPdb(pdbName) {
        if (!jsmolApplet) {
            console.error("JSmol applet is not initialized");
            return;
        }

        console.log("loadPdb**", pdbName);
        const pdbUrl = `https://files.rcsb.org/download/${pdbName}.pdb`; // Public PDB file URL
        const scriptCommand = `
            load ${pdbUrl};
            cartoon on;
            spacefill on;
        `;
        console.log("Executing JSmol script:", scriptCommand);

        Jmol.script(jsmolApplet, scriptCommand, function(info) {
            if (info && info.error) {
                console.error("JSmol script error:", info.error);
            } else {
                console.log("JSmol script executed:", info);
            }
        });
}*/


	// Add a drag behavior.
    node.call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));

	/*
	
		> Enables the nodes to be dragged and updates the node positions during dragging.

	*/
	
    // Set the position attributes of links and nodes each time the simulation ticks.
	
    function ticked() {
        link
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
			.attr("x2", d => {
				const dx = d.target.x - d.source.x;
				const dy = d.target.y - d.source.y;
				const distance = Math.sqrt(dx * dx + dy * dy);
				const unitX = dx / distance;
				const unitY = dy / distance;
				return d.target.x - unitX * 26; // 20 is the radius of the circle
			})
			.attr("y2", d => {
				const dx = d.target.x - d.source.x;
				const dy = d.target.y - d.source.y;
				const distance = Math.sqrt(dx * dx + dy * dy);
				const unitX = dx / distance;
				const unitY = dy / distance;
				return d.target.y - unitY * 26; // 20 is the radius of the circle
			});

        node
            .attr("cx", d => d.x)
            .attr("cy", d => d.y);

        label
            .attr("x", d => d.x)
            .attr("y", d => d.y);
    }

	/*
	
		> Updates the positions of the links, nodes, and labels based on the simulation's current state.
	
	*/
	
    // Zoom function
    function zoomed(event) {
        container.attr("transform", event.transform);
    }

	/*
	
		> Adjusts the transform attribute of the container group to handle the zooming.

	
	*/
	//*******************************************************************************
	
// Reheat the simulation when drag starts, and fix the subject position.
		function dragstarted(event, d) {
			if (!event.active) simulation.alphaTarget(0.3).restart();

			// Fix the position of the dragged node
			d.fx = event.subject.x;
			d.fy = event.subject.y;

			// Add a circle to visualize the minimum distance
			const minDistanceCircle = d3.select(this).append("circle")
				.attr("class", "min-distance-circle")
				.attr("cx", 0)
				.attr("cy", 0)
				.attr("r", 100)  // You can adjust this distance as needed
				.attr("stroke", "red")
				.attr("stroke-dasharray", "4")
				.attr("fill", "none");

			// Unfix the positions of the connected nodes
			copiedLinks.forEach(link => {
				if (link.source === d) {
					link.target.fx = null;
					link.target.fy = null;
				} else if (link.target === d) {
					link.source.fx = null;
					link.source.fy = null;
				}
			});
		}

		// Update the subject (dragged node) position during drag.
		function dragged(event) {
			event.subject.fx = event.x;
			event.subject.fy = event.y;
		}

		// Restore the target alpha so the simulation cools after dragging ends.
		// Unfix the subject position now that it’s no longer being dragged.
		function dragended(event) {
			if (!event.active) simulation.alphaTarget(0);
			event.subject.fx = null;
			event.subject.fy = null;

			// Remove the minimum distance circle
			d3.select(this).select(".min-distance-circle").remove();
		}


	/*
	
		> dragstarted sets the position of the dragged node and visualizes the minimum distance with a circle.
		> dragged updates the position of the dragged node.
		> dragended restores the simulation's alpha and removes the minimum distance circle.
	
	*/

	//*******************************************************************************

		
	
	   
 		// Handle click event
		function handleClick(event, d) {
			console.log("Clicked node:", d.id);
			console.log(d);
			
			const moleculeInfoDiv = document.getElementById('molecule-info');
    		moleculeInfoDiv.style.display = 'none';
			
			// Check if the result comes from MATCH (n:Molecule) RETURN n LIMIT 25
			if (d.labels && d.labels.includes("Molecule")) {
				const smiles = d.properties && d.properties.smile ? d.properties.smile.trim() : "";
				if (smiles) {
					console.log(`Attempting to load 2D representation for SMILES: ${smiles}`);
					load2DRepresentation(smiles);
				} else {
					console.error("SMILES not found for the selected molecule.");
				}
			}
			// Check if the result comes from MATCH (n1)-[r]->(n2) RETURN r, n1, n2 LIMIT 25
			else if (d.properties && d.properties.pdb) {
				const pdbName = d.properties.pdb.trim();
				if (pdbName) {
					console.log(`Attempting to load ${pdbName}.pdb`);
					loadPdb(pdbName);
				} else {
					console.error("PDB name not found for the selected node.");
				}
			} else {
				console.error("Unknown node type or property.");
			}
		
			console.log("fetch : test");
			
			// URL du répertoire
			const directoryURL = `http://localhost:8080/personnalisation/arbo/pdb_prepared/${d.properties.pdb.trim()}/site_0/dirjson/`;
			console.log("fetch : ", directoryURL);
			
			// Fetch the list of file names
			 fetch(directoryURL)
				.then(response => {
					if (!response.ok) {
						throw new Error('Failed to fetch file names');
					}
					// Vérifier si la réponse est HTML
					if (response.headers.get('content-type').includes('text/html')) {
						// Traitement de la réponse HTML
						return response.text();
					} else {
						// Si la réponse n'est pas HTML, gérer l'erreur
						throw new Error('Unexpected content type');
					}
				})
				.then(html => {
					// Analyser la réponse HTML et extraire les noms de fichiers DLmol_
					const parser = new DOMParser();
					const doc = parser.parseFromString(html, 'text/html');
					// Exemple d'extraction de données en utilisant querySelectorAll
					const fileLinks = Array.from(doc.querySelectorAll('a')).map(link => link.textContent);
					console.log('File names:', fileLinks);

					// Filtrer les noms de fichiers DLmol_ et supprimer les extensions
					const uniqueNames = [...new Set(fileLinks.filter(name => name.startsWith('DLmol_')).map(name => name.split('.')[0]))];				 
				 
					// Afficher les noms de fichiers sans extension dans infoDiv
					const infoDiv = document.getElementById('info-div');
					infoDiv.innerHTML = `
						<p><span style="font-size: 16px; font-weight: bold; color: #2a2c33;">ID: </span><span style="font-size: 16px; font-weight: bold; color: #fff;">${d.id}</span></p>
						<p><span style="font-size: 16px; font-weight: bold; color: #2a2c33;">Name: </span><span style="font-size: 16px; font-weight: bold; color: #fff;">${d.properties.name}</span></p>
						<p><span style="font-size: 16px; font-weight: bold; color: #2a2c33;">Label: </span><span style="font-size: 16px; font-weight: bold; color: #fff;">${d.labels[0]}</span></p>
						<ul>
							${uniqueNames.map(name => `<li>${name}</li>`).join('')}
						</ul>
					`;
				infoDiv.style.display = 'block';    

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Fonction pour charger et afficher la partie du fichier PDB correspondant à l'InChIKey cliqué
function loadAndDisplayMoleculePDB(clickedInchikey, dlmolFileName) {
    const pdbURL = `http://localhost:8080/personnalisation/arbo/pdb_prepared/${d.properties.pdb.trim()}/site_0/dirjson/${dlmolFileName}.pdb`;
    console.log('Fetching PDB:', pdbURL);
    // Charger le fichier PDB
    fetch(pdbURL)
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to fetch PDB data');
            }
            return response.text();
        })
        .then(pdbData => {
            console.log('PDB data:', pdbData);
            // Extraire la partie du fichier PDB correspondant à la molécule
            const moleculePDB = extractMoleculePDB(clickedInchikey, pdbData);
            console.log('Molecule PDB:', moleculePDB);
            // Utiliser la partie du fichier PDB pour afficher la représentation moléculaire avec JSmol		
			const pdb = `load INLINE '${moleculePDB}';`;
            loadPdb2(pdb);
		
        })
        .catch(error => {
            console.error('Error fetching or processing PDB data:', error);
        });
}

	
	
// Fonction pour extraire la partie du fichier PDB correspondant à la molécule
function extractMoleculePDB(inchikey, pdbData) {
    const startMarker = `MOL_ID: ${inchikey}`;
    const endMarker = 'END';
    const startIndex = pdbData.indexOf(startMarker);
    const endIndex = pdbData.indexOf(endMarker, startIndex);
    if (startIndex !== -1 && endIndex !== -1) {
        return pdbData.substring(startIndex, endIndex + endMarker.length);
    } else {
        console.error('Molecule section not found in PDB data for InChIKey:', inchikey);
        return null;
    }
}

	// Fonction pour gérer le clic sur un élément InChIKey
function handleInchikeyClick(item, dlmolFileName) {
    const clickedInchikeyElement = item.querySelector('p:first-child');
    const clickedInchikey = clickedInchikeyElement.textContent.replace('InCh: ', '');
    loadAndDisplayMoleculePDB(clickedInchikey, `${dlmolFileName}.pdb`);
}

// Fonction pour afficher les informations de la molécule sélectionnée
function displaySelectedMoleculeInfo(molecules, name) {
					// Générer la chaîne HTML contenant les informations de la molécule
					let inchikeyHTML = `<h5 style="color: black;">InChIKeys & SMILES</h5><ul>`;
					molecules.forEach(molecule => {
						inchikeyHTML += `<li class="inchikey-item"><p>InCh: ${molecule.properties.inchikey}</p><p>Smile: ${molecule.properties.smile}</p></li>`;
					});
					inchikeyHTML += '</ul>';

					// Insérer la chaîne HTML dans le div cible
					const moleculeInfoDiv = document.getElementById('molecule-info');
					moleculeInfoDiv.innerHTML = inchikeyHTML;
					moleculeInfoDiv.style.display = 'block';

					// Ajouter un gestionnaire d'événements click à chaque élément InChIKey
					
					console.log("xxxxxxxxxxxxxxxxxxxxxxxxxxxxx");

					const inchikeyItems = document.querySelectorAll('.inchikey-item');
					console.log(inchikeyItems);

					inchikeyItems.forEach(item => {
						console.log("ssssssssssssssssssssssssss");
						item.addEventListener('click', () => {
							const clickedInchikeyElement = item.querySelector('p:first-child'); // Sélectionne le premier élément <p> dans le <li> pour obtenir l'InChIKey
							const clickedInchikey = clickedInchikeyElement.textContent.replace('InCh: ', ''); // Obtient l'InChIKey à partir du texte du premier <p>
							const clickedMolecule = molecules.find(molecule => molecule.properties.inchikey === clickedInchikey);
							if (clickedMolecule) {
								const clickedSmileElement = item.querySelector('p:nth-child(2)'); // Sélectionne le deuxième élément <p> dans le <li> pour obtenir le SMILE
								const clickedSmile = clickedSmileElement.textContent.replace('Smile: ', ''); // Obtient le SMILE à partir du texte du deuxième <p>
								// Utilise le SMILE pour afficher la structure moléculaire dans JSME
								load2DRepresentation(clickedSmile);
								loadAndDisplayMoleculePDB(clickedInchikey, name);

							}
						});
					});
					
				}
	

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
				 

				// Ajouter un gestionnaire d'événements click à chaque nom de fichier DLmol_
				uniqueNames.forEach(name => {
					infoDiv.querySelectorAll('li').forEach(li => {
						if (li.textContent === name) {
							li.addEventListener('click', () => {
								console.log('Clicked file name:', name);
								// Construire l'URL du fichier JSON correspondant
								const jsonURL = `http://localhost:8080/personnalisation/arbo/pdb_prepared/${d.properties.pdb.trim()}/site_0/dirjson/${name}.json`;
								console.log('Fetching JSON:', jsonURL);
								// Récupérer le fichier JSON correspondant
								fetch(jsonURL)
									.then(response => {
										if (!response.ok) {
											throw new Error('Failed to fetch JSON data');
										}
										return response.json();
									})
									.then(data => {
										console.log('JSON data:', data);
										// Extraire les informations nécessaires du fichier JSON
										displaySelectedMoleculeInfo(data.molecules, name); 
										const inchikeys = data.molecules.map(molecule => molecule.properties.inchikey);
										console.log('InChIKeys:', inchikeys);
									
									})
									.catch(error => {
										console.error('Error fetching or processing JSON data:', error);
									});
							});
							
							
							
						}
					});
				});

				 
				})
				.catch(error => {
					console.error('Error fetching or processing HTML response:', error);
					// Gérer l'erreur de manière appropriée
				});
		}
	
	
		// Function to fetch PDB information
		function getPdbInfo(pdbName) {
			console.log("pdbName:", pdbName);
			return fetch(`https://data.rcsb.org/rest/v1/core/entry/${pdbName}`)
				.then(response => {
					if (!response.ok) {
						throw new Error(`Error ${response.status} while fetching PDB data.`);
					}
					return response.json();
				})
				.then(data => {
					
					//console.log("getPdbInfo");
					/*console.log({
						title: data.struct.title,
						pubTitle: data.citation[0].title,
						classification: data.struct_keywords.pdbx_keywords,
						genes: data.struct_keywords.text
					});*/
				
					// Return the fetched data
					return {
						title: data.struct.title,
						pubTitle: data.citation[0].title,
						classification: data.struct_keywords.pdbx_keywords,
						genes: data.struct_keywords.text
					};
				})
				.catch(error => {
					console.error(error.message);
					// Return an empty object in case of error
					return {};
				});
		}

		// Function to fetch UniProt information
		function getUniProtInfo(accession) {
			console.log("accession:", accession);
			return fetch(`https://www.ebi.ac.uk/proteins/api/proteins?offset=0&size=100&accession=${accession}`, {
				headers: {
					'Accept': 'application/json'
				}
			})
			.then(response => {
				if (!response.ok) {
					throw new Error(`Error ${response.status} while fetching UniProt data.`);
				}
				// Since we have explicitly requested JSON, we can directly parse the response as JSON
				return response.json();
			})
			.then(data => {
				// Extract relevant information from the JSON response
				//console.log("datadata");
				//console.log(data);
				const entry = data[0];
				const proteinName = entry.protein.recommendedName.fullName.value;
				const geneName = entry.gene[0].name.value;
				const organism = entry.organism.names[0].value;
				const functionDescription = entry.comments.find(comment => comment.type === 'FUNCTION');
				
				
				//console.log("getUniProtInfo");
				/*console.log({
					proteinName: proteinName,
					geneName: geneName,
					organism: organism,
					functionDescription: functionDescription ? functionDescription.text[0].value : "Function information not available"
				});*/
				
				return {
					proteinName: proteinName,
					geneName: geneName,
					organism: organism,
					functionDescription: functionDescription ? functionDescription.text[0].value : "Function information not available"
				};
			})
			.catch(error => {
				console.error(error.message);
			});
		}


		// Handle mouseover event
		function handleMouseover(event, d) {
			d3.select(this).attr("fill", "#ff5733");
			
			//console.log("label : ", d.labels[0]);
			
			// Check if the node has a PDB property
			if (d.properties && d.labels.includes("Site")) {
				// Fetch PDB info and update tooltip when data is available
				getPdbInfo(d.properties.pdb)
					.then(pdbInfo => {
						const tooltipText = `
							<span style="font-size: 16px; font-weight: bold; color: #2a2c33;">ID:</span> <span style="font-size: 16px; font-weight: bold; color: #fff;">${d.id}</span><br>
							<span style="font-size: 16px; font-weight: bold; color: #2a2c33;">PDB:</span> <span style="color: #fff;">${d.properties.pdb}</span><br>
							<span style="font-size: 16px; font-weight: bold; color: #2a2c33;">Title:</span> <span style="color: #fff;">${pdbInfo.title}</span><br>
							<span style="font-size: 16px; font-weight: bold; color: #2a2c33;">Publication Title:</span> <span style="color: #fff;">${pdbInfo.pubTitle}</span><br>
							<span style="font-size: 16px; font-weight: bold; color: #2a2c33;">Classification:</span> <span style="color: #fff;">${pdbInfo.classification}</span><br>
							<span style="font-size: 16px; font-weight: bold; color: #2a2c33;">Genes:</span> <span style="color: #fff;">${pdbInfo.genes}</span>
						`;
						// Set the tooltip content and position
						tooltip.style("visibility", "visible")
							.html(tooltipText)
							.style("top", (event.pageY - 10) + "px")
							.style("left", (event.pageX + 10) + "px");
					});
			} 
			
	// Check if the node has an accession property
    if (d.properties && d.labels.includes("Protein")) {
        // Fetch UniProt info and update tooltip when data is available
        getUniProtInfo(d.properties.name)
            .then(uniProtInfo => {
                const tooltipText = `
                    <span style="font-size: 16px; font-weight: bold; color: #2a2c33;">ID:</span> <span style="font-size: 16px; font-weight: bold; color: #fff;">${d.id}</span><br>
                    <span style="font-size: 16px; font-weight: bold; color: #2a2c33;">Name:</span> <span style="color: #fff;">${d.properties.name}</span><br>
                    <span style="font-size: 16px; font-weight: bold; color: #2a2c33;">UniProt Protein:</span> <span style="color: #fff;">${uniProtInfo.proteinName}</span><br>
                    <span style="font-size: 16px; font-weight: bold; color: #2a2c33;">Gene:</span> <span style="color: #fff;">${uniProtInfo.geneName}</span><br>
                    <span style="font-size: 16px; font-weight: bold; color: #2a2c33;">Organism:</span> <span style="color: #fff;">${uniProtInfo.organism}</span><br>
                    <span style="font-size: 16px; font-weight: bold; color: #2a2c33;">Function:</span> <span style="color: #fff;">${uniProtInfo.functionDescription}</span>
                `;
                // Set the tooltip content and position
                tooltip.style("visibility", "visible")
                    .html(tooltipText)
                    .style("top", (event.pageY - 10) + "px")
                    .style("left", (event.pageX + 10) + "px");
            });
    } else {
        // If the node doesn't have an accession property, display "UniProt: Not available"
        const tooltipText = `
            <span style="font-size: 16px; font-weight: bold; color: #2a2c33;">ID:</span> <span style="font-size: 16px; font-weight: bold; color: #fff;">${d.id}</span><br>
            <span style="font-size: 16px; font-weight: bold; color: #2a2c33;">Name:</span> <span style="color: #fff;">${d.properties.name}</span><br>
            </span> <span style="color: #FF0000; font-weight: bold;">Not available</span>
        `;
        // Set the tooltip content and position
        tooltip.style("visibility", "visible")
            .html(tooltipText)
            .style("top", (event.pageY - 10) + "px")
            .style("left", (event.pageX + 10) + "px");
    }
			
		}


		// Handle mousemove event
		function handleMousemove(event) {
			tooltip.style("top", (event.pageY - 10) + "px")
				.style("left", (event.pageX + 10) + "px");
		}

		// Handle mouseout event
		function handleMouseout(event, d) {
			d3.select(this).attr("fill", d => color(d.labels[0]));
			tooltip.style("visibility", "hidden");
		}
	
    // When this cell is re-run, stop the previous simulation.
    invalidation.then(() => simulation.stop());
}



function responsiveSvgSizer() {
    const svg = d3.select('#graphSvg');
    const rect = svg.node().parentNode.getBoundingClientRect();
    const dpr = window.devicePixelRatio;

    svg.attr("width", rect.width * dpr)
        .attr("height", 600 * dpr)
        .style("width", `${rect.width}px`)
        .style("height", `${600}px`);
	
}

